import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'

export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient()

    if (!supabase) {
      console.error("‚ùå Impossible de cr√©er le client Supabase")
      return NextResponse.json(
        { error: 'Erreur de configuration' },
        { status: 500 }
      )
    }

    const { data: { session }, error: authError } = await supabase.auth.getSession()

    if (authError || !session) {
      console.error("‚ùå Erreur auth √©valuations:", authError)
      return NextResponse.json(
        { 
          success: false,
          error: 'Non autoris√©',
          evaluations: []
        },
        { status: 401 }
      )
    }

    console.log("‚úÖ Session trouv√©e pour √©valuations:", session.user.email)

    // V√©rifier le r√¥le de l'utilisateur
    const { data: userProfile, error: profileError } = await supabase
      .from("users")
      .select("role, name")
      .eq("id", session.user.id)
      .single()

    if (profileError || !userProfile) {
      console.error("‚ùå Erreur profil utilisateur:", profileError)
      return NextResponse.json(
        { error: 'Utilisateur non trouv√©' },
        { status: 404 }
      )
    }

    console.log("‚úÖ R√¥le utilisateur:", userProfile.role, "Nom:", userProfile.name)

    const { searchParams } = new URL(request.url)
    const stagiaireId = searchParams.get('stagiaire_id')
    const tuteurId = searchParams.get('tuteur_id')

    // R√©cup√©rer l'√©valuation avec tous les d√©tails
    let query = supabase
      .from('evaluations')
      .select(`
        *,
        stagiaire:stagiaires!inner(
          id,
          user_id,
          specialite,
          niveau,
          users!inner(name, email),
          tuteur:users!stagiaires_tuteur_id_fkey(name, email)
        ),
        evaluateur:users!evaluations_evaluateur_id_fkey(name, email)
      `)
      .order('created_at', { ascending: false })

    // Filtres selon les param√®tres
    if (stagiaireId) {
      console.log("üîç Filtre par stagiaire:", stagiaireId)
      query = query.eq('stagiaire_id', stagiaireId)
    }

    if (tuteurId) {
      console.log("üîç Filtre par tuteur:", tuteurId)
      query = query.eq('evaluateur_id', tuteurId)
    }

    // Filtres selon le r√¥le
    if (userProfile.role === 'tuteur') {
      // Les tuteurs ne voient que les √©valuations qu'ils ont cr√©√©es
      console.log("üîç Filtre tuteur - √©valuations cr√©√©es par:", session.user.id)
      query = query.eq('evaluateur_id', session.user.id)
    } else if (userProfile.role === 'stagiaire') {
      // Les stagiaires ne voient que leurs propres √©valuations
      const { data: stagiaireProfile } = await supabase
        .from('stagiaires')
        .select('id')
        .eq('user_id', session.user.id)
        .single()

      if (stagiaireProfile) {
        console.log("üîç Filtre stagiaire - √©valuations pour:", stagiaireProfile.id)
        query = query.eq('stagiaire_id', stagiaireProfile.id)
      }
    } else if (['admin', 'rh'].includes(userProfile.role)) {
      console.log("üîç Admin/RH - acc√®s √† toutes les √©valuations")
      // Les admins et RH voient toutes les √©valuations (pas de filtre suppl√©mentaire)
    }

    console.log("üîç Ex√©cution de la requ√™te √©valuations...")
    const { data, error } = await query

    if (error) {
      console.error('‚ùå Erreur get evaluations:', error)
      console.error('‚ùå D√©tails erreur:', error.message, error.hint)
      return NextResponse.json(
        { 
          success: false, 
          error: 'Erreur lors de la r√©cup√©ration des √©valuations: ' + error.message,
          evaluations: []
        },
        { status: 500 }
      )
    }

    console.log("‚úÖ √âvaluations r√©cup√©r√©es:", data?.length || 0)

    // Log des donn√©es pour debug
    if (data && data.length > 0) {
      console.log("üìã Premi√®re √©valuation:", JSON.stringify(data[0], null, 2))
    }

    return NextResponse.json({
      success: true,
      evaluations: data || [],
      total: data?.length || 0,
      user_role: userProfile.role
    })

  } catch (error) {
    console.error('üí• Erreur evaluations:', error)
    return NextResponse.json(
      { error: 'Erreur serveur' },
      { status: 500 }
    )
  }
}

export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { session }, error: authError } = await supabase.auth.getSession()

    if (authError || !session) {
      console.error("‚ùå Erreur auth √©valuation POST:", authError)
      return NextResponse.json(
        { error: 'Non autoris√©' },
        { status: 401 }
      )
    }

    const evaluationData = await request.json()
    console.log("üìã Donn√©es √©valuation re√ßues:", evaluationData)

    // V√©rifier que les champs requis sont pr√©sents
    if (!evaluationData.stagiaire_id) {
      return NextResponse.json(
        { error: 'ID du stagiaire requis' },
        { status: 400 }
      )
    }

    // V√©rifier que le stagiaire existe
    const { data: stagiaireExists, error: stagiaireError } = await supabase
      .from('stagiaires')
      .select('id')
      .eq('id', evaluationData.stagiaire_id)
      .single()

    if (stagiaireError || !stagiaireExists) {
      console.error("‚ùå Stagiaire non trouv√©:", evaluationData.stagiaire_id)
      return NextResponse.json(
        { error: 'Stagiaire non trouv√©' },
        { status: 404 }
      )
    }

    // Pr√©parer les donn√©es pour l'insertion
    const insertData = {
      stagiaire_id: evaluationData.stagiaire_id,
      evaluateur_id: session.user.id,
      periode_debut: evaluationData.periode_debut,
      periode_fin: evaluationData.periode_fin,
      type: evaluationData.type || 'mi_parcours',
      note_globale: evaluationData.note_globale || 0,
      competences_techniques: evaluationData.competences_techniques || 0,
      competences_relationnelles: evaluationData.competences_relationnelles || 0,
      autonomie: evaluationData.autonomie || 0,
      ponctualite: evaluationData.ponctualite || 0,
      motivation: evaluationData.motivation || 0,
      commentaires: evaluationData.commentaires || '',
      points_forts: evaluationData.points_forts || '',
      axes_amelioration: evaluationData.axes_amelioration || '',
      objectifs_suivants: evaluationData.objectifs_suivants || '',
      recommandations: evaluationData.recommandations || '',
      statut: evaluationData.statut || 'brouillon',
      created_at: new Date().toISOString()
    }

    console.log("üíæ Donn√©es √† ins√©rer:", insertData)

    const { data, error } = await supabase
      .from('evaluations')
      .insert(insertData)
      .select(`
        *,
        stagiaire:stagiaires!inner(
          id,
          user_id,
          specialite,
          niveau,
          users!inner(name, email)
        ),
        evaluateur:users!evaluations_evaluateur_id_fkey(name, email)
      `)

    if (error) {
      console.error('‚ùå Erreur create evaluation:', error)
      console.error('‚ùå D√©tails erreur:', error.message, error.hint, error.details)
      return NextResponse.json(
        { error: 'Erreur lors de la cr√©ation de l\'√©valuation: ' + error.message },
        { status: 500 }
      )
    }

    console.log("‚úÖ √âvaluation cr√©√©e:", data[0])

    return NextResponse.json({
      success: true,
      data: data[0],
      message: '√âvaluation cr√©√©e avec succ√®s'
    }, { status: 201 })

  } catch (error) {
    console.error('üí• Erreur create evaluation:', error)
    return NextResponse.json(
      { error: 'Erreur serveur' },
      { status: 500 }
    )
  }
}
