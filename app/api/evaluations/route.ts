import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'

export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient()

    if (!supabase) {
      console.error("‚ùå Impossible de cr√©er le client Supabase")
      return NextResponse.json(
        { error: 'Erreur de configuration' },
        { status: 500 }
      )
    }

    const { data: { session }, error: authError } = await supabase.auth.getSession()

    if (authError || !session) {
      console.error("‚ùå Erreur auth √©valuations:", authError)
      return NextResponse.json(
        { 
          success: false,
          error: 'Non autoris√©',
          evaluations: []
        },
        { status: 401 }
      )
    }

    console.log("‚úÖ Session trouv√©e pour √©valuations:", session.user.email)

    // V√©rifier le r√¥le de l'utilisateur
    const { data: userProfile, error: profileError } = await supabase
      .from("users")
      .select("role, name")
      .eq("id", session.user.id)
      .single()

    if (profileError || !userProfile) {
      console.error("‚ùå Erreur profil utilisateur:", profileError)
      return NextResponse.json(
        { error: 'Utilisateur non trouv√©' },
        { status: 404 }
      )
    }

    console.log("‚úÖ R√¥le utilisateur:", userProfile.role, "Nom:", userProfile.name)

    const { searchParams } = new URL(request.url)
    const stagiaireId = searchParams.get('stagiaire_id')
    const tuteurId = searchParams.get('tuteur_id')

    // R√©cup√©rer l'√©valuation avec tous les d√©tails
    let query = supabase
      .from('evaluations')
      .select(`
        *,
        stagiaire:stagiaires!inner(
          id,
          user_id,
          specialite,
          niveau,
          users!inner(name, email),
          tuteur:users!stagiaires_tuteur_id_fkey(name, email)
        ),
        evaluateur:users!evaluations_evaluateur_id_fkey(name, email)
      `)
      .order('created_at', { ascending: false })

    // Filtres selon les param√®tres
    if (stagiaireId) {
      console.log("üîç Filtre par stagiaire:", stagiaireId)
      query = query.eq('stagiaire_id', stagiaireId)
    }

    if (tuteurId) {
      console.log("üîç Filtre par tuteur:", tuteurId)
      query = query.eq('evaluateur_id', tuteurId)
    }

    // Filtres selon le r√¥le
    if (userProfile.role === 'tuteur') {
      // Les tuteurs ne voient que les √©valuations qu'ils ont cr√©√©es
      console.log("üîç Filtre tuteur - √©valuations cr√©√©es par:", session.user.id)
      query = query.eq('evaluateur_id', session.user.id)
    } else if (userProfile.role === 'stagiaire') {
      // Les stagiaires ne voient que leurs propres √©valuations
      const { data: stagiaireProfile } = await supabase
        .from('stagiaires')
        .select('id')
        .eq('user_id', session.user.id)
        .single()

      if (stagiaireProfile) {
        console.log("üîç Filtre stagiaire - √©valuations pour:", stagiaireProfile.id)
        query = query.eq('stagiaire_id', stagiaireProfile.id)
      }
    } else if (['admin', 'rh'].includes(userProfile.role)) {
      console.log("üîç Admin/RH - acc√®s √† toutes les √©valuations")
      // Les admins et RH voient toutes les √©valuations (pas de filtre suppl√©mentaire)
    }

    console.log("üîç Ex√©cution de la requ√™te √©valuations...")
    const { data, error } = await query

    if (error) {
      console.error('‚ùå Erreur get evaluations:', error)
      console.error('‚ùå D√©tails erreur:', error.message, error.hint)
      return NextResponse.json(
        { 
          success: false, 
          error: 'Erreur lors de la r√©cup√©ration des √©valuations: ' + error.message,
          evaluations: []
        },
        { status: 500 }
      )
    }

    console.log("‚úÖ √âvaluations r√©cup√©r√©es:", data?.length || 0)

    // Log des donn√©es pour debug
    if (data && data.length > 0) {
      console.log("üìã Premi√®re √©valuation:", JSON.stringify(data[0], null, 2))
    }

    return NextResponse.json({
      success: true,
      evaluations: data || [],
      total: data?.length || 0,
      user_role: userProfile.role
    })

  } catch (error) {
    console.error('üí• Erreur evaluations:', error)
    return NextResponse.json(
      { error: 'Erreur serveur' },
      { status: 500 }
    )
  }
}

export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { session }, error: authError } = await supabase.auth.getSession()

    if (authError || !session) {
      return NextResponse.json(
        { error: 'Non autoris√©' },
        { status: 401 }
      )
    }

    const evaluationData = await request.json()

    const { data, error } = await supabase
      .from('evaluations')
      .insert({
        ...evaluationData,
        evaluateur_id: session.user.id,
        created_at: new Date().toISOString()
      })
      .select()

    if (error) {
      console.error('‚ùå Erreur create evaluation:', error)
      return NextResponse.json(
        { error: 'Erreur lors de la cr√©ation de l\'√©valuation' },
        { status: 500 }
      )
    }

    return NextResponse.json(data[0], { status: 201 })

  } catch (error) {
    console.error('üí• Erreur create evaluation:', error)
    return NextResponse.json(
      { error: 'Erreur serveur' },
      { status: 500 }
    )
  }
}
import { NextRequest, NextResponse } from "next/server"
import { createClient } from "@/lib/supabase/server"

export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient()
    
    // V√©rifier l'authentification
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: "Non autoris√©" }, { status: 401 })
    }

    // R√©cup√©rer le profil utilisateur
    const { data: profile, error: profileError } = await supabase
      .from("users")
      .select("role")
      .eq("id", user.id)
      .single()

    if (profileError || !profile) {
      return NextResponse.json({ error: "Profil non trouv√©" }, { status: 404 })
    }

    // R√©cup√©rer les √©valuations selon le r√¥le
    let evaluationsQuery

    if (["admin", "rh"].includes(profile.role)) {
      // Admin/RH peuvent voir toutes les √©valuations
      evaluationsQuery = supabase
        .from("evaluations")
        .select(`
          *,
          stagiaire:stagiaires(
            id,
            entreprise,
            poste,
            users!inner(name, email)
          ),
          tuteur:users!tuteur_id(name, email)
        `)
        .order("created_at", { ascending: false })
    } else if (profile.role === "tuteur") {
      // Tuteurs voient leurs √©valuations
      evaluationsQuery = supabase
        .from("evaluations")
        .select(`
          *,
          stagiaire:stagiaires(
            id,
            entreprise,
            poste,
            users!inner(name, email)
          ),
          tuteur:users!tuteur_id(name, email)
        `)
        .eq("tuteur_id", user.id)
        .order("created_at", { ascending: false })
    } else if (profile.role === "stagiaire") {
      // Stagiaires voient leurs √©valuations
      const { data: stagiaireProfile } = await supabase
        .from("stagiaires")
        .select("id")
        .eq("user_id", user.id)
        .single()

      if (stagiaireProfile) {
        evaluationsQuery = supabase
          .from("evaluations")
          .select(`
            *,
            stagiaire:stagiaires(
              id,
              entreprise,
              poste,
              users!inner(name, email)
            ),
            tuteur:users!tuteur_id(name, email)
          `)
          .eq("stagiaire_id", stagiaireProfile.id)
          .order("created_at", { ascending: false })
      } else {
        return NextResponse.json({ 
          success: true, 
          data: [],
          total: 0 
        })
      }
    } else {
      return NextResponse.json({ error: "Acc√®s refus√©" }, { status: 403 })
    }

    const { data: evaluations, error: evaluationsError } = await evaluationsQuery

    if (evaluationsError) {
      console.error("Erreur r√©cup√©ration √©valuations:", evaluationsError)
      return NextResponse.json({ 
        error: "Erreur lors de la r√©cup√©ration des √©valuations" 
      }, { status: 500 })
    }

    return NextResponse.json({
      success: true,
      data: evaluations || [],
      total: evaluations?.length || 0
    })

  } catch (error) {
    console.error("Erreur API √©valuations:", error)
    return NextResponse.json({ 
      error: "Erreur serveur" 
    }, { status: 500 })
  }
}

export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()
    
    // V√©rifier l'authentification
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: "Non autoris√©" }, { status: 401 })
    }

    const body = await request.json()
    const { stagiaire_id, tuteur_id, ...evaluationData } = body

    // Cr√©er l'√©valuation
    const { data: evaluation, error: evaluationError } = await supabase
      .from("evaluations")
      .insert({
        ...evaluationData,
        stagiaire_id,
        tuteur_id: tuteur_id || user.id,
        created_by: user.id,
        created_at: new Date().toISOString()
      })
      .select()
      .single()

    if (evaluationError) {
      console.error("Erreur cr√©ation √©valuation:", evaluationError)
      return NextResponse.json({ 
        error: "Erreur lors de la cr√©ation de l'√©valuation" 
      }, { status: 500 })
    }

    return NextResponse.json({
      success: true,
      data: evaluation,
      message: "√âvaluation cr√©√©e avec succ√®s"
    })

  } catch (error) {
    console.error("Erreur cr√©ation √©valuation:", error)
    return NextResponse.json({ 
      error: "Erreur serveur" 
    }, { status: 500 })
  }
}
